{
    "docs": [
        {
            "location": "/", 
            "text": "LBRY JSON-RPC API Documentation\n\n\nblob_announce_all\n\n\nAnnounce all blobs to the DHT\n\nArgs:\n    None\nReturns:\n    (str) Success/fail message\n\n\n\n\nblob_delete\n\n\nDelete a blob\n\nArgs:\n    'blob_hash': (str) hash of blob to get\nReturns:\n    (str) Success/fail message\n\n\n\n\nblob_get\n\n\nDownload and return a blob\n\nArgs:\n    'blob_hash': (str) blob hash of blob to get\n    'timeout'(optional): (int) timeout in number of seconds\n    'encoding'(optional): (str) by default no attempt at decoding is made,\n                         can be set to one of the following decoders:\n                         'json'\n    'payment_rate_manager'(optional): if not given the default payment rate manager\n                                     will be used. supported alternative rate managers:\n                                     'only-free'\n\nReturns\n    (str) Success/Fail message or (dict) decoded data\n\n\n\n\nblob_list\n\n\nReturns blob hashes. If not given filters, returns all blobs known by the blob manager\n\nArgs:\n    'uri' (optional): (str) filter by blobs in stream for winning claim\n    'stream_hash' (optional): (str) filter by blobs in given stream hash\n    'sd_hash' (optional): (str) filter by blobs in given sd hash\n    'needed' (optional): (bool) only return needed blobs\n    'finished' (optional): (bool) only return finished blobs\n    'page_size' (optional): (int) limit number of results returned\n    'page' (optional): (int) filter to page x of [page_size] results\nReturns:\n    (list) List of blob hashes\n\n\n\n\nblob_reflect_all\n\n\nReflects all saved blobs\n\nArgs:\n    None\nReturns:\n    (bool) true if successful\n\n\n\n\nblock_show\n\n\nGet contents of a block\n\nArgs:\n    'blockhash': (str) hash of the block to look up\nReturns:\n    (dict) Requested block\n\n\n\n\nchannel_list_mine\n\n\nGet my channels\n\nReturns:\n    (list) ClaimDict\n\n\n\n\nchannel_new\n\n\nGenerate a publisher key and create a new certificate claim\n\nArgs:\n    'channel_name': (str) '@' prefixed name\n    'amount': (float) amount to claim name\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }\n\n\n\n\nclaim_abandon\n\n\nAbandon a name and reclaim credits from the claim\n\nArgs:\n    'claim_id': (str) claim_id of claim\nReturn:\n    (dict) Dictionary containing result of the claim\n    {\n        txid : (str) txid of resulting transaction\n        fee : (float) fee paid for the transaction\n    }\n\n\n\n\nclaim_list\n\n\nGet claims for a name\n\nArgs:\n    'name': (str) search for claims on this name\nReturns\n    (dict) State of claims assigned for the name\n    {\n        'claims': (list) list of claims for the name\n        [\n            {\n            'amount': (float) amount assigned to the claim\n            'effective_amount': (float) total amount assigned to the claim,\n                                including supports\n            'claim_id': (str) claim ID of the claim\n            'height': (int) height of block containing the claim\n            'txid': (str) txid of the claim\n            'nout': (int) nout of the claim\n            'supports': (list) a list of supports attached to the claim\n            'value': (str) the value of the claim\n            },\n        ]\n        'supports_without_claims': (list) supports without any claims attached to them\n        'last_takeover_height': (int) the height of last takeover for the name\n    }\n\n\n\n\nclaim_list_mine\n\n\nList my name claims\n\nArgs:\n    None\nReturns\n    (list) List of name claims owned by user\n    [\n        {\n            'address': (str) address that owns the claim\n            'amount': (float) amount assigned to the claim\n            'blocks_to_expiration': (int) number of blocks until it expires\n            'category': (str) \nclaim\n, \nupdate\n , or \nsupport\n\n            'claim_id': (str) claim ID of the claim\n            'confirmations': (int) number of blocks of confirmations for the claim\n            'expiration_height': (int) the block height which the claim will expire\n            'expired': (bool) true if expired, false otherwise\n            'height': (int) height of the block containing the claim\n            'is_spent': (bool) true if claim is abandoned, false otherwise\n            'name': (str) name of the claim\n            'txid': (str) txid of the cliam\n            'nout': (int) nout of the claim\n            'value': (str) value of the claim\n        },\n   ]\n\n\n\n\nclaim_new_support\n\n\nSupport a name claim\n\nArgs:\n    'name': (str) name\n    'claim_id': (str) claim ID of claim to support\n    'amount': (float) amount to support by\nReturn:\n    (dict) Dictionary containing result of the claim\n    {\n        txid : (str) txid of resulting support claim\n        nout : (int) nout of the resulting support claim\n        fee : (float) fee paid for the transaction\n    }\n\n\n\n\nclaim_show\n\n\nResolve claim info from a LBRY name\n\nArgs:\n    'name': (str) name to look up, do not include lbry:// prefix\n    'txid'(optional): (str) if specified, look for claim with this txid\n    'nout'(optional): (int) if specified, look for claim with this nout\n    'claim_id'(optional): (str) if specified, look for claim with this claim_id\nReturns:\n    (dict) Dictionary contaning claim info, (bool) false if claim is not\n        resolvable\n\n    {\n        'txid': (str) txid of claim\n        'nout': (int) nout of claim\n        'amount': (float) amount of claim\n        'value': (str) value of claim\n        'height' : (int) height of claim takeover\n        'claim_id': (str) claim ID of claim\n        'supports': (list) list of supports associated with claim\n    }\n\n\n\n\ncommands\n\n\nReturn a list of available commands\n\nReturns:\n    (list) list of available commands\n\n\n\n\ndaemon_stop\n\n\nStop lbrynet-daemon\n\nReturns:\n    (string) Shutdown message\n\n\n\n\ndescriptor_get\n\n\nDownload and return a sd blob\n\nArgs:\n    'sd_hash': (str) hash of sd blob\n    'timeout'(optional): (int) timeout in number of seconds\n    'payment_rate_manager'(optional): (str) if not given the default payment rate manager\n                                     will be used. supported alternative rate managers:\n                                     only-free\n\nReturns\n    (str) Success/Fail message or (dict) decoded data\n\n\n\n\nfile_delete\n\n\nDelete a lbry file\n\nArgs:\n    'name' (optional): (str) delete file by lbry name,\n    'sd_hash' (optional): (str) delete file by sd hash,\n    'file_name' (optional): (str) delete file by the name in the downloads folder,\n    'stream_hash' (optional): (str) delete file by stream hash,\n    'claim_id' (optional): (str) delete file by claim ID,\n    'outpoint' (optional): (str) delete file by claim outpoint,\n    'rowid': (optional): (int) delete file by rowid in the file manager\n    'delete_target_file' (optional): (bool) delete file from downloads folder,\n                                    defaults to true if false only the blobs and\n                                    db entries will be deleted\nReturns:\n    (bool) true if deletion was successful\n\n\n\n\nfile_list\n\n\nList files limited by optional filters\n\nArgs:\n    'name' (optional): (str) filter files by lbry name,\n    'sd_hash' (optional): (str) filter files by sd hash,\n    'file_name' (optional): (str) filter files by the name in the downloads folder,\n    'stream_hash' (optional): (str) filter files by stream hash,\n    'claim_id' (optional): (str) filter files by claim id,\n    'outpoint' (optional): (str) filter files by claim outpoint,\n    'rowid' (optional): (int) filter files by internal row id,\n    'full_status': (optional): (bool) if true populate the 'message' and 'size' fields\n\nReturns:\n    (list) List of files\n\n    [\n        {\n            'completed': (bool) true if download is completed,\n            'file_name': (str) name of file,\n            'download_directory': (str) download directory,\n            'points_paid': (float) credit paid to download file,\n            'stopped': (bool) true if download is stopped,\n            'stream_hash': (str) stream hash of file,\n            'stream_name': (str) stream name ,\n            'suggested_file_name': (str) suggested file name,\n            'sd_hash': (str) sd hash of file,\n            'name': (str) name claim attached to file\n            'outpoint': (str) claim outpoint attached to file\n            'claim_id': (str) claim ID attached to file,\n            'download_path': (str) download path of file,\n            'mime_type': (str) mime type of file,\n            'key': (str) key attached to file,\n            'total_bytes': (int) file size in bytes, None if full_status is false\n            'written_bytes': (int) written size in bytes\n            'message': (str), None if full_status is false\n            'metadata': (dict) Metadata dictionary\n        },\n    ]\n\n\n\n\nfile_set_status\n\n\nStart or stop downloading a file\n\nArgs:\n    'status': (str) \nstart\n or \nstop\n\n    'name' (optional): (str) start file by lbry name,\n    'sd_hash' (optional): (str) start file by the hash in the name claim,\n    'file_name' (optional): (str) start file by its name in the downloads folder,\nReturns:\n    (str) Confirmation message\n\n\n\n\nget\n\n\nDownload stream from a LBRY name.\n\nArgs:\n    'uri': (str) lbry uri to download\n    'file_name'(optional): (str) a user specified name for the downloaded file\n    'timeout'(optional): (int) download timeout in number of seconds\n    'download_directory'(optional): (str) path to directory where file will be saved\nReturns:\n    (dict) Dictionary contaning information about the stream\n    {\n        'completed': (bool) true if download is completed,\n        'file_name': (str) name of file,\n        'download_directory': (str) download directory,\n        'points_paid': (float) credit paid to download file,\n        'stopped': (bool) true if download is stopped,\n        'stream_hash': (str) stream hash of file,\n        'stream_name': (str) stream name,\n        'suggested_file_name': (str) suggested file name,\n        'sd_hash': (str) sd hash of file,\n        'name': (str) name claim attached to file\n        'outpoint': (str) claim outpoint attached to file\n        'claim_id': (str) claim ID attached to file,\n        'download_path': (str) download path of file,\n        'mime_type': (str) mime type of file,\n        'key': (str) key attached to file,\n        'total_bytes': (int) file size in bytes, None if full_status is false\n        'written_bytes': (int) written size in bytes\n        'message': (str), None if full_status is false\n        'metadata': (dict) Metadata dictionary\n    }\n\n\n\n\nget_availability\n\n\nGet stream availability for lbry uri\n\nArgs:\n    'uri' : (str) lbry uri\n    'sd_timeout' (optional): (int) sd blob download timeout\n    'peer_timeout' (optional): (int) how long to look for peers\n\nReturns:\n    (float) Peers per blob / total blobs\n\n\n\n\nhelp\n\n\nReturn a useful message for an API command\n\nArgs:\n    'command'(optional): (str) command to retrieve documentation for\nReturns:\n    (str) if given a command, returns documentation about that command\n    otherwise returns general help message\n\n\n\n\npeer_list\n\n\nGet peers for blob hash\n\nArgs:\n    'blob_hash': (str) blob hash\n    'timeout'(optional): (int) peer search timeout in seconds\nReturns:\n    (list) List of contacts\n\n\n\n\npublish\n\n\nMake a new name claim and publish associated data to lbrynet,\nupdate over existing claim if user already has a claim for name.\n\nFields required in the final Metadata are:\n    'title'\n    'description'\n    'author'\n    'language'\n    'license',\n    'nsfw'\n\nMetadata can be set by either using the metadata argument or by setting individual arguments\nfee, title, description, author, language, license, license_url, thumbnail, preview, nsfw,\nor sources. Individual arguments will overwrite the fields specified in metadata argument.\n\nArgs:\n    'name': (str) name to be claimed\n    'bid': (float) amount of credits to commit in this claim,\n    'metadata'(optional): (dict) Metadata to associate with the claim.\n    'file_path'(optional): (str) path to file to be associated with name. If provided,\n                            a lbry stream of this file will be used in 'sources'.\n                            If no path is given but a metadata dict is provided, the source\n                            from the given metadata will be used.\n    'fee'(optional): (dict) Dictionary representing key fee to download content:\n                      {currency_symbol: {'amount': float, 'address': str, optional}}\n                      supported currencies: LBC, USD, BTC\n                      If an address is not provided a new one will be automatically\n                      generated. Default fee is zero.\n    'title'(optional): (str) title of the file\n    'description'(optional): (str) description of the file\n    'author'(optional): (str) author of the file\n    'language'(optional): (str), language code\n    'license'(optional): (str) license for the file\n    'license_url'(optional): (str) URL to license\n    'thumbnail'(optional): (str) thumbnail URL for the file\n    'preview'(optional): (str) preview URL for the file\n    'nsfw'(optional): (bool) True if not safe for work\n    'sources'(optional): (dict){'lbry_sd_hash':sd_hash} specifies sd hash of file\n    'channel_name' (optional): (str) name of the publisher channel\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }\n\n\n\n\nreflect\n\n\nReflect a stream\n\nArgs:\n    'sd_hash': (str) sd_hash of lbry file\nReturns:\n    (bool) true if successful\n\n\n\n\nreport_bug\n\n\nReport a bug to slack\n\nArgs:\n    'message': (str) message to send\nReturns:\n    (bool) true if successful\n\n\n\n\nresolve\n\n\nResolve a LBRY URI\n\nArgs:\n    'uri': (str) uri to download\nReturns:\n    None if nothing can be resolved, otherwise:\n    If uri resolves to a channel or a claim in a channel:\n        'certificate': {\n            'address': (str) claim address,\n            'amount': (float) claim amount,\n            'effective_amount': (float) claim amount including supports,\n            'claim_id': (str) claim id,\n            'claim_sequence': (int) claim sequence number,\n            'decoded_claim': (bool) whether or not the claim value was decoded,\n            'height': (int) claim height,\n            'depth': (int) claim depth,\n            'has_signature': (bool) included if decoded_claim\n            'name': (str) claim name,\n            'supports: (list) list of supports [{'txid': txid,\n                                                 'nout': nout,\n                                                 'amount': amount}],\n            'txid': (str) claim txid,\n            'nout': (str) claim nout,\n            'signature_is_valid': (bool), included if has_signature,\n            'value': ClaimDict if decoded, otherwise hex string\n        }\n    If uri resolves to a channel:\n        'claims_in_channel': [\n            {\n                'address': (str) claim address,\n                'amount': (float) claim amount,\n                'effective_amount': (float) claim amount including supports,\n                'claim_id': (str) claim id,\n                'claim_sequence': (int) claim sequence number,\n                'decoded_claim': (bool) whether or not the claim value was decoded,\n                'height': (int) claim height,\n                'depth': (int) claim depth,\n                'has_signature': (bool) included if decoded_claim\n                'name': (str) claim name,\n                'supports: (list) list of supports [{'txid': txid,\n                                                     'nout': nout,\n                                                     'amount': amount}],\n                'txid': (str) claim txid,\n                'nout': (str) claim nout,\n                'signature_is_valid': (bool), included if has_signature,\n                'value': ClaimDict if decoded, otherwise hex string\n            }\n        ]\n    If uri resolves to a claim:\n        'claim': {\n            'address': (str) claim address,\n            'amount': (float) claim amount,\n            'effective_amount': (float) claim amount including supports,\n            'claim_id': (str) claim id,\n            'claim_sequence': (int) claim sequence number,\n            'decoded_claim': (bool) whether or not the claim value was decoded,\n            'height': (int) claim height,\n            'depth': (int) claim depth,\n            'has_signature': (bool) included if decoded_claim\n            'name': (str) claim name,\n            'channel_name': (str) channel name if claim is in a channel\n            'supports: (list) list of supports [{'txid': txid,\n                                                 'nout': nout,\n                                                 'amount': amount}]\n            'txid': (str) claim txid,\n            'nout': (str) claim nout,\n            'signature_is_valid': (bool), included if has_signature,\n            'value': ClaimDict if decoded, otherwise hex string\n        }\n    }\n\n\n\n\nresolve_name\n\n\nResolve stream info from a LBRY name\n\nArgs:\n    'name': (str) name to look up, do not include lbry:// prefix\nReturns:\n    (dict) Metadata dictionary from name claim, None if the name is not\n            resolvable\n\n\n\n\nsend_amount_to_address\n\n\nSend credits to an address\n\nArgs:\n    'amount': (float) the amount to send\n    'address': (str) the address of the recipient in base58\nReturns:\n    (bool) true if payment successfully scheduled\n\n\n\n\nsettings_get\n\n\nGet daemon settings\n\nReturns:\n    (dict) Dictionary of daemon settings\n    See ADJUSTABLE_SETTINGS in lbrynet/conf.py for full list of settings\n\n\n\n\nsettings_set\n\n\nSet daemon settings\n\nArgs:\n    'run_on_startup': (bool) currently not supported\n    'data_rate': (float) data rate,\n    'max_key_fee': (float) maximum key fee,\n    'download_directory': (str) path of where files are downloaded,\n    'max_upload': (float), currently not supported\n    'max_download': (float), currently not supported\n    'download_timeout': (int) download timeout in seconds\n    'search_timeout': (float) search timeout in seconds\n    'cache_time': (int) cache timeout in seconds\nReturns:\n    (dict) Updated dictionary of daemon settings\n\n\n\n\nstatus\n\n\nReturn daemon status\n\nArgs:\n    'session_status' (optional): (bool) true to return session status,\n        default is false\nReturns:\n    (dict) Daemon status dictionary\n\n\n\n\nstream_cost_estimate\n\n\nGet estimated cost for a lbry stream\n\nArgs:\n    'name': (str) lbry name\n    'size' (optional): (int) stream size, in bytes. if provided an sd blob\n                        won't be downloaded.\nReturns:\n    (float) Estimated cost in lbry credits, returns None if uri is not\n        resolveable\n\n\n\n\ntransaction_list\n\n\nList transactions belonging to wallet\n\nArgs:\n    None\nReturns:\n    (list) List of transactions\n\n\n\n\ntransaction_show\n\n\nGet a decoded transaction from a txid\n\nArgs:\n    'txid': (str) txid of transaction\nReturns:\n    (dict) JSON formatted transaction\n\n\n\n\nversion\n\n\nGet lbry version information\n\nArgs:\n    None\nReturns:\n    (dict) Dictionary of lbry version information\n    {\n        'build': (str) build type (e.g. \ndev\n, \nrc\n, \nrelease\n),\n        'ip': (str) remote ip, if available,\n        'lbrynet_update_available': (bool) whether there's an update available,\n        'lbrynet_version': (str) lbrynet_version,\n        'lbryum_version': (str) lbryum_version,\n        'lbryschema_version': (str) lbryschema_version,\n        'os_release': (str) os release string\n        'os_system': (str) os name\n        'platform': (str) platform string\n        'processor': (str) processor type,\n        'python_version': (str) python version,\n        'remote_lbrynet': (str) most recent lbrynet version available from github\n    }\n\n\n\n\nwallet_balance\n\n\nReturn the balance of the wallet\n\nArgs:\n    'address' (optional): If address is provided only that balance will be given\n    'include_unconfirmed' (optional): If set unconfirmed balance will be included in\n     the only takes effect when address is also provided.\n\nReturns:\n    (float) amount of lbry credits in wallet\n\n\n\n\nwallet_is_address_mine\n\n\nChecks if an address is associated with the current wallet.\n\nArgs:\n    'address': (str) address to check in base58\nReturns:\n    (bool) true, if address is associated with current wallet\n\n\n\n\nwallet_list\n\n\nList wallet addresses\n\nArgs:\n    None\nReturns:\n    List of wallet addresses\n\n\n\n\nwallet_new_address\n\n\nGenerate a new wallet address\n\nArgs:\n    None\nReturns:\n    (str) New wallet address in base58\n\n\n\n\nwallet_public_key\n\n\nGet public key from wallet address\n\nArgs:\n    'address': (str) wallet address in base58\nReturns:\n    (list) list of public keys associated with address.\n        Could contain more than one public key if multisig.\n\n\n\n\nwallet_unused_address\n\n\nReturn an address containing no balance, will create\na new address if there is none.\n\nArgs:\n    None\nReturns:\n    (str) Unused wallet address in base58", 
            "title": "API"
        }, 
        {
            "location": "/#lbry-json-rpc-api-documentation", 
            "text": "", 
            "title": "LBRY JSON-RPC API Documentation"
        }, 
        {
            "location": "/#blob_announce_all", 
            "text": "Announce all blobs to the DHT\n\nArgs:\n    None\nReturns:\n    (str) Success/fail message", 
            "title": "blob_announce_all"
        }, 
        {
            "location": "/#blob_delete", 
            "text": "Delete a blob\n\nArgs:\n    'blob_hash': (str) hash of blob to get\nReturns:\n    (str) Success/fail message", 
            "title": "blob_delete"
        }, 
        {
            "location": "/#blob_get", 
            "text": "Download and return a blob\n\nArgs:\n    'blob_hash': (str) blob hash of blob to get\n    'timeout'(optional): (int) timeout in number of seconds\n    'encoding'(optional): (str) by default no attempt at decoding is made,\n                         can be set to one of the following decoders:\n                         'json'\n    'payment_rate_manager'(optional): if not given the default payment rate manager\n                                     will be used. supported alternative rate managers:\n                                     'only-free'\n\nReturns\n    (str) Success/Fail message or (dict) decoded data", 
            "title": "blob_get"
        }, 
        {
            "location": "/#blob_list", 
            "text": "Returns blob hashes. If not given filters, returns all blobs known by the blob manager\n\nArgs:\n    'uri' (optional): (str) filter by blobs in stream for winning claim\n    'stream_hash' (optional): (str) filter by blobs in given stream hash\n    'sd_hash' (optional): (str) filter by blobs in given sd hash\n    'needed' (optional): (bool) only return needed blobs\n    'finished' (optional): (bool) only return finished blobs\n    'page_size' (optional): (int) limit number of results returned\n    'page' (optional): (int) filter to page x of [page_size] results\nReturns:\n    (list) List of blob hashes", 
            "title": "blob_list"
        }, 
        {
            "location": "/#blob_reflect_all", 
            "text": "Reflects all saved blobs\n\nArgs:\n    None\nReturns:\n    (bool) true if successful", 
            "title": "blob_reflect_all"
        }, 
        {
            "location": "/#block_show", 
            "text": "Get contents of a block\n\nArgs:\n    'blockhash': (str) hash of the block to look up\nReturns:\n    (dict) Requested block", 
            "title": "block_show"
        }, 
        {
            "location": "/#channel_list_mine", 
            "text": "Get my channels\n\nReturns:\n    (list) ClaimDict", 
            "title": "channel_list_mine"
        }, 
        {
            "location": "/#channel_new", 
            "text": "Generate a publisher key and create a new certificate claim\n\nArgs:\n    'channel_name': (str) '@' prefixed name\n    'amount': (float) amount to claim name\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }", 
            "title": "channel_new"
        }, 
        {
            "location": "/#claim_abandon", 
            "text": "Abandon a name and reclaim credits from the claim\n\nArgs:\n    'claim_id': (str) claim_id of claim\nReturn:\n    (dict) Dictionary containing result of the claim\n    {\n        txid : (str) txid of resulting transaction\n        fee : (float) fee paid for the transaction\n    }", 
            "title": "claim_abandon"
        }, 
        {
            "location": "/#claim_list", 
            "text": "Get claims for a name\n\nArgs:\n    'name': (str) search for claims on this name\nReturns\n    (dict) State of claims assigned for the name\n    {\n        'claims': (list) list of claims for the name\n        [\n            {\n            'amount': (float) amount assigned to the claim\n            'effective_amount': (float) total amount assigned to the claim,\n                                including supports\n            'claim_id': (str) claim ID of the claim\n            'height': (int) height of block containing the claim\n            'txid': (str) txid of the claim\n            'nout': (int) nout of the claim\n            'supports': (list) a list of supports attached to the claim\n            'value': (str) the value of the claim\n            },\n        ]\n        'supports_without_claims': (list) supports without any claims attached to them\n        'last_takeover_height': (int) the height of last takeover for the name\n    }", 
            "title": "claim_list"
        }, 
        {
            "location": "/#claim_list_mine", 
            "text": "List my name claims\n\nArgs:\n    None\nReturns\n    (list) List of name claims owned by user\n    [\n        {\n            'address': (str) address that owns the claim\n            'amount': (float) amount assigned to the claim\n            'blocks_to_expiration': (int) number of blocks until it expires\n            'category': (str)  claim ,  update  , or  support \n            'claim_id': (str) claim ID of the claim\n            'confirmations': (int) number of blocks of confirmations for the claim\n            'expiration_height': (int) the block height which the claim will expire\n            'expired': (bool) true if expired, false otherwise\n            'height': (int) height of the block containing the claim\n            'is_spent': (bool) true if claim is abandoned, false otherwise\n            'name': (str) name of the claim\n            'txid': (str) txid of the cliam\n            'nout': (int) nout of the claim\n            'value': (str) value of the claim\n        },\n   ]", 
            "title": "claim_list_mine"
        }, 
        {
            "location": "/#claim_new_support", 
            "text": "Support a name claim\n\nArgs:\n    'name': (str) name\n    'claim_id': (str) claim ID of claim to support\n    'amount': (float) amount to support by\nReturn:\n    (dict) Dictionary containing result of the claim\n    {\n        txid : (str) txid of resulting support claim\n        nout : (int) nout of the resulting support claim\n        fee : (float) fee paid for the transaction\n    }", 
            "title": "claim_new_support"
        }, 
        {
            "location": "/#claim_show", 
            "text": "Resolve claim info from a LBRY name\n\nArgs:\n    'name': (str) name to look up, do not include lbry:// prefix\n    'txid'(optional): (str) if specified, look for claim with this txid\n    'nout'(optional): (int) if specified, look for claim with this nout\n    'claim_id'(optional): (str) if specified, look for claim with this claim_id\nReturns:\n    (dict) Dictionary contaning claim info, (bool) false if claim is not\n        resolvable\n\n    {\n        'txid': (str) txid of claim\n        'nout': (int) nout of claim\n        'amount': (float) amount of claim\n        'value': (str) value of claim\n        'height' : (int) height of claim takeover\n        'claim_id': (str) claim ID of claim\n        'supports': (list) list of supports associated with claim\n    }", 
            "title": "claim_show"
        }, 
        {
            "location": "/#commands", 
            "text": "Return a list of available commands\n\nReturns:\n    (list) list of available commands", 
            "title": "commands"
        }, 
        {
            "location": "/#daemon_stop", 
            "text": "Stop lbrynet-daemon\n\nReturns:\n    (string) Shutdown message", 
            "title": "daemon_stop"
        }, 
        {
            "location": "/#descriptor_get", 
            "text": "Download and return a sd blob\n\nArgs:\n    'sd_hash': (str) hash of sd blob\n    'timeout'(optional): (int) timeout in number of seconds\n    'payment_rate_manager'(optional): (str) if not given the default payment rate manager\n                                     will be used. supported alternative rate managers:\n                                     only-free\n\nReturns\n    (str) Success/Fail message or (dict) decoded data", 
            "title": "descriptor_get"
        }, 
        {
            "location": "/#file_delete", 
            "text": "Delete a lbry file\n\nArgs:\n    'name' (optional): (str) delete file by lbry name,\n    'sd_hash' (optional): (str) delete file by sd hash,\n    'file_name' (optional): (str) delete file by the name in the downloads folder,\n    'stream_hash' (optional): (str) delete file by stream hash,\n    'claim_id' (optional): (str) delete file by claim ID,\n    'outpoint' (optional): (str) delete file by claim outpoint,\n    'rowid': (optional): (int) delete file by rowid in the file manager\n    'delete_target_file' (optional): (bool) delete file from downloads folder,\n                                    defaults to true if false only the blobs and\n                                    db entries will be deleted\nReturns:\n    (bool) true if deletion was successful", 
            "title": "file_delete"
        }, 
        {
            "location": "/#file_list", 
            "text": "List files limited by optional filters\n\nArgs:\n    'name' (optional): (str) filter files by lbry name,\n    'sd_hash' (optional): (str) filter files by sd hash,\n    'file_name' (optional): (str) filter files by the name in the downloads folder,\n    'stream_hash' (optional): (str) filter files by stream hash,\n    'claim_id' (optional): (str) filter files by claim id,\n    'outpoint' (optional): (str) filter files by claim outpoint,\n    'rowid' (optional): (int) filter files by internal row id,\n    'full_status': (optional): (bool) if true populate the 'message' and 'size' fields\n\nReturns:\n    (list) List of files\n\n    [\n        {\n            'completed': (bool) true if download is completed,\n            'file_name': (str) name of file,\n            'download_directory': (str) download directory,\n            'points_paid': (float) credit paid to download file,\n            'stopped': (bool) true if download is stopped,\n            'stream_hash': (str) stream hash of file,\n            'stream_name': (str) stream name ,\n            'suggested_file_name': (str) suggested file name,\n            'sd_hash': (str) sd hash of file,\n            'name': (str) name claim attached to file\n            'outpoint': (str) claim outpoint attached to file\n            'claim_id': (str) claim ID attached to file,\n            'download_path': (str) download path of file,\n            'mime_type': (str) mime type of file,\n            'key': (str) key attached to file,\n            'total_bytes': (int) file size in bytes, None if full_status is false\n            'written_bytes': (int) written size in bytes\n            'message': (str), None if full_status is false\n            'metadata': (dict) Metadata dictionary\n        },\n    ]", 
            "title": "file_list"
        }, 
        {
            "location": "/#file_set_status", 
            "text": "Start or stop downloading a file\n\nArgs:\n    'status': (str)  start  or  stop \n    'name' (optional): (str) start file by lbry name,\n    'sd_hash' (optional): (str) start file by the hash in the name claim,\n    'file_name' (optional): (str) start file by its name in the downloads folder,\nReturns:\n    (str) Confirmation message", 
            "title": "file_set_status"
        }, 
        {
            "location": "/#get", 
            "text": "Download stream from a LBRY name.\n\nArgs:\n    'uri': (str) lbry uri to download\n    'file_name'(optional): (str) a user specified name for the downloaded file\n    'timeout'(optional): (int) download timeout in number of seconds\n    'download_directory'(optional): (str) path to directory where file will be saved\nReturns:\n    (dict) Dictionary contaning information about the stream\n    {\n        'completed': (bool) true if download is completed,\n        'file_name': (str) name of file,\n        'download_directory': (str) download directory,\n        'points_paid': (float) credit paid to download file,\n        'stopped': (bool) true if download is stopped,\n        'stream_hash': (str) stream hash of file,\n        'stream_name': (str) stream name,\n        'suggested_file_name': (str) suggested file name,\n        'sd_hash': (str) sd hash of file,\n        'name': (str) name claim attached to file\n        'outpoint': (str) claim outpoint attached to file\n        'claim_id': (str) claim ID attached to file,\n        'download_path': (str) download path of file,\n        'mime_type': (str) mime type of file,\n        'key': (str) key attached to file,\n        'total_bytes': (int) file size in bytes, None if full_status is false\n        'written_bytes': (int) written size in bytes\n        'message': (str), None if full_status is false\n        'metadata': (dict) Metadata dictionary\n    }", 
            "title": "get"
        }, 
        {
            "location": "/#get_availability", 
            "text": "Get stream availability for lbry uri\n\nArgs:\n    'uri' : (str) lbry uri\n    'sd_timeout' (optional): (int) sd blob download timeout\n    'peer_timeout' (optional): (int) how long to look for peers\n\nReturns:\n    (float) Peers per blob / total blobs", 
            "title": "get_availability"
        }, 
        {
            "location": "/#help", 
            "text": "Return a useful message for an API command\n\nArgs:\n    'command'(optional): (str) command to retrieve documentation for\nReturns:\n    (str) if given a command, returns documentation about that command\n    otherwise returns general help message", 
            "title": "help"
        }, 
        {
            "location": "/#peer_list", 
            "text": "Get peers for blob hash\n\nArgs:\n    'blob_hash': (str) blob hash\n    'timeout'(optional): (int) peer search timeout in seconds\nReturns:\n    (list) List of contacts", 
            "title": "peer_list"
        }, 
        {
            "location": "/#publish", 
            "text": "Make a new name claim and publish associated data to lbrynet,\nupdate over existing claim if user already has a claim for name.\n\nFields required in the final Metadata are:\n    'title'\n    'description'\n    'author'\n    'language'\n    'license',\n    'nsfw'\n\nMetadata can be set by either using the metadata argument or by setting individual arguments\nfee, title, description, author, language, license, license_url, thumbnail, preview, nsfw,\nor sources. Individual arguments will overwrite the fields specified in metadata argument.\n\nArgs:\n    'name': (str) name to be claimed\n    'bid': (float) amount of credits to commit in this claim,\n    'metadata'(optional): (dict) Metadata to associate with the claim.\n    'file_path'(optional): (str) path to file to be associated with name. If provided,\n                            a lbry stream of this file will be used in 'sources'.\n                            If no path is given but a metadata dict is provided, the source\n                            from the given metadata will be used.\n    'fee'(optional): (dict) Dictionary representing key fee to download content:\n                      {currency_symbol: {'amount': float, 'address': str, optional}}\n                      supported currencies: LBC, USD, BTC\n                      If an address is not provided a new one will be automatically\n                      generated. Default fee is zero.\n    'title'(optional): (str) title of the file\n    'description'(optional): (str) description of the file\n    'author'(optional): (str) author of the file\n    'language'(optional): (str), language code\n    'license'(optional): (str) license for the file\n    'license_url'(optional): (str) URL to license\n    'thumbnail'(optional): (str) thumbnail URL for the file\n    'preview'(optional): (str) preview URL for the file\n    'nsfw'(optional): (bool) True if not safe for work\n    'sources'(optional): (dict){'lbry_sd_hash':sd_hash} specifies sd hash of file\n    'channel_name' (optional): (str) name of the publisher channel\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }", 
            "title": "publish"
        }, 
        {
            "location": "/#reflect", 
            "text": "Reflect a stream\n\nArgs:\n    'sd_hash': (str) sd_hash of lbry file\nReturns:\n    (bool) true if successful", 
            "title": "reflect"
        }, 
        {
            "location": "/#report_bug", 
            "text": "Report a bug to slack\n\nArgs:\n    'message': (str) message to send\nReturns:\n    (bool) true if successful", 
            "title": "report_bug"
        }, 
        {
            "location": "/#resolve", 
            "text": "Resolve a LBRY URI\n\nArgs:\n    'uri': (str) uri to download\nReturns:\n    None if nothing can be resolved, otherwise:\n    If uri resolves to a channel or a claim in a channel:\n        'certificate': {\n            'address': (str) claim address,\n            'amount': (float) claim amount,\n            'effective_amount': (float) claim amount including supports,\n            'claim_id': (str) claim id,\n            'claim_sequence': (int) claim sequence number,\n            'decoded_claim': (bool) whether or not the claim value was decoded,\n            'height': (int) claim height,\n            'depth': (int) claim depth,\n            'has_signature': (bool) included if decoded_claim\n            'name': (str) claim name,\n            'supports: (list) list of supports [{'txid': txid,\n                                                 'nout': nout,\n                                                 'amount': amount}],\n            'txid': (str) claim txid,\n            'nout': (str) claim nout,\n            'signature_is_valid': (bool), included if has_signature,\n            'value': ClaimDict if decoded, otherwise hex string\n        }\n    If uri resolves to a channel:\n        'claims_in_channel': [\n            {\n                'address': (str) claim address,\n                'amount': (float) claim amount,\n                'effective_amount': (float) claim amount including supports,\n                'claim_id': (str) claim id,\n                'claim_sequence': (int) claim sequence number,\n                'decoded_claim': (bool) whether or not the claim value was decoded,\n                'height': (int) claim height,\n                'depth': (int) claim depth,\n                'has_signature': (bool) included if decoded_claim\n                'name': (str) claim name,\n                'supports: (list) list of supports [{'txid': txid,\n                                                     'nout': nout,\n                                                     'amount': amount}],\n                'txid': (str) claim txid,\n                'nout': (str) claim nout,\n                'signature_is_valid': (bool), included if has_signature,\n                'value': ClaimDict if decoded, otherwise hex string\n            }\n        ]\n    If uri resolves to a claim:\n        'claim': {\n            'address': (str) claim address,\n            'amount': (float) claim amount,\n            'effective_amount': (float) claim amount including supports,\n            'claim_id': (str) claim id,\n            'claim_sequence': (int) claim sequence number,\n            'decoded_claim': (bool) whether or not the claim value was decoded,\n            'height': (int) claim height,\n            'depth': (int) claim depth,\n            'has_signature': (bool) included if decoded_claim\n            'name': (str) claim name,\n            'channel_name': (str) channel name if claim is in a channel\n            'supports: (list) list of supports [{'txid': txid,\n                                                 'nout': nout,\n                                                 'amount': amount}]\n            'txid': (str) claim txid,\n            'nout': (str) claim nout,\n            'signature_is_valid': (bool), included if has_signature,\n            'value': ClaimDict if decoded, otherwise hex string\n        }\n    }", 
            "title": "resolve"
        }, 
        {
            "location": "/#resolve_name", 
            "text": "Resolve stream info from a LBRY name\n\nArgs:\n    'name': (str) name to look up, do not include lbry:// prefix\nReturns:\n    (dict) Metadata dictionary from name claim, None if the name is not\n            resolvable", 
            "title": "resolve_name"
        }, 
        {
            "location": "/#send_amount_to_address", 
            "text": "Send credits to an address\n\nArgs:\n    'amount': (float) the amount to send\n    'address': (str) the address of the recipient in base58\nReturns:\n    (bool) true if payment successfully scheduled", 
            "title": "send_amount_to_address"
        }, 
        {
            "location": "/#settings_get", 
            "text": "Get daemon settings\n\nReturns:\n    (dict) Dictionary of daemon settings\n    See ADJUSTABLE_SETTINGS in lbrynet/conf.py for full list of settings", 
            "title": "settings_get"
        }, 
        {
            "location": "/#settings_set", 
            "text": "Set daemon settings\n\nArgs:\n    'run_on_startup': (bool) currently not supported\n    'data_rate': (float) data rate,\n    'max_key_fee': (float) maximum key fee,\n    'download_directory': (str) path of where files are downloaded,\n    'max_upload': (float), currently not supported\n    'max_download': (float), currently not supported\n    'download_timeout': (int) download timeout in seconds\n    'search_timeout': (float) search timeout in seconds\n    'cache_time': (int) cache timeout in seconds\nReturns:\n    (dict) Updated dictionary of daemon settings", 
            "title": "settings_set"
        }, 
        {
            "location": "/#status", 
            "text": "Return daemon status\n\nArgs:\n    'session_status' (optional): (bool) true to return session status,\n        default is false\nReturns:\n    (dict) Daemon status dictionary", 
            "title": "status"
        }, 
        {
            "location": "/#stream_cost_estimate", 
            "text": "Get estimated cost for a lbry stream\n\nArgs:\n    'name': (str) lbry name\n    'size' (optional): (int) stream size, in bytes. if provided an sd blob\n                        won't be downloaded.\nReturns:\n    (float) Estimated cost in lbry credits, returns None if uri is not\n        resolveable", 
            "title": "stream_cost_estimate"
        }, 
        {
            "location": "/#transaction_list", 
            "text": "List transactions belonging to wallet\n\nArgs:\n    None\nReturns:\n    (list) List of transactions", 
            "title": "transaction_list"
        }, 
        {
            "location": "/#transaction_show", 
            "text": "Get a decoded transaction from a txid\n\nArgs:\n    'txid': (str) txid of transaction\nReturns:\n    (dict) JSON formatted transaction", 
            "title": "transaction_show"
        }, 
        {
            "location": "/#version", 
            "text": "Get lbry version information\n\nArgs:\n    None\nReturns:\n    (dict) Dictionary of lbry version information\n    {\n        'build': (str) build type (e.g.  dev ,  rc ,  release ),\n        'ip': (str) remote ip, if available,\n        'lbrynet_update_available': (bool) whether there's an update available,\n        'lbrynet_version': (str) lbrynet_version,\n        'lbryum_version': (str) lbryum_version,\n        'lbryschema_version': (str) lbryschema_version,\n        'os_release': (str) os release string\n        'os_system': (str) os name\n        'platform': (str) platform string\n        'processor': (str) processor type,\n        'python_version': (str) python version,\n        'remote_lbrynet': (str) most recent lbrynet version available from github\n    }", 
            "title": "version"
        }, 
        {
            "location": "/#wallet_balance", 
            "text": "Return the balance of the wallet\n\nArgs:\n    'address' (optional): If address is provided only that balance will be given\n    'include_unconfirmed' (optional): If set unconfirmed balance will be included in\n     the only takes effect when address is also provided.\n\nReturns:\n    (float) amount of lbry credits in wallet", 
            "title": "wallet_balance"
        }, 
        {
            "location": "/#wallet_is_address_mine", 
            "text": "Checks if an address is associated with the current wallet.\n\nArgs:\n    'address': (str) address to check in base58\nReturns:\n    (bool) true, if address is associated with current wallet", 
            "title": "wallet_is_address_mine"
        }, 
        {
            "location": "/#wallet_list", 
            "text": "List wallet addresses\n\nArgs:\n    None\nReturns:\n    List of wallet addresses", 
            "title": "wallet_list"
        }, 
        {
            "location": "/#wallet_new_address", 
            "text": "Generate a new wallet address\n\nArgs:\n    None\nReturns:\n    (str) New wallet address in base58", 
            "title": "wallet_new_address"
        }, 
        {
            "location": "/#wallet_public_key", 
            "text": "Get public key from wallet address\n\nArgs:\n    'address': (str) wallet address in base58\nReturns:\n    (list) list of public keys associated with address.\n        Could contain more than one public key if multisig.", 
            "title": "wallet_public_key"
        }, 
        {
            "location": "/#wallet_unused_address", 
            "text": "Return an address containing no balance, will create\na new address if there is none.\n\nArgs:\n    None\nReturns:\n    (str) Unused wallet address in base58", 
            "title": "wallet_unused_address"
        }
    ]
}